# Config Console

> In order to configure the login messsage for all the users on the system, you've been given access to a configuration console. See if you can get a shell on shell2017.picoctf.com:11496. console Source

Hints:

> You can either see where libc is or modify the execution. Is there a way to get the vulnerability to run twice so that you can do both?

> There's a place in libc that will give you a shell as soon as you jump to it. Try looking for execve.

It wasn't an easy challenge. We were given a binary and the source code, what's more the vulnerability was easy to spot, but creating an exploit was very time consuming and there were some unexpected problems with it.

First we had to find a vulnerability, as I mentioned it was rather obvious one.
```c
void set_exit_message(char *message) {
    if (!message) {
        printf("No message chosen\n");
        exit(1);
    }
    printf("Exit message set!\n");
    printf(message);

    append_command('e', message);
    exit(0);
}
```
We control first argument to `printf` and it means format string vulnerability. We usually use `printf` for printing, so it's not necessarily obvious that printf can write to variables too.
Anyway, it can and we'll have to use it.

If we read hints, we can see that probably we'll need to find a way to run a vulnerability twice. Here comes the first problem. Just after our message is printed they call exit. We can't overwrite return address, because it won't be ever used.

However, PIE is disabled for this application, so we know where exactly the binary will be placed in memory. It means we can read/write `.got.plt` and `.plt` sections.
We also know all addresses in `.text` section, so probably the best choice is to overwrite `exit` address with `loop` address.
```
got.plt exit is located at 0x601258
loop starts at 0x4009BD
```
Because exit wasn't run yet, the `.got.plt` entry will contain pointer to `.plt` entry for `exit` (otherwise it would contain pointer to `exit` in libc, but it doesn't really matter).
```
plt exit 0x400736
```
We can see that we only have to overwrite two lower bytes.

We can also get libc address in one go. Normally main function has to return somewhere and the place where it returns is somewhere in `__libc_start_main`.
We sometimes call this place `__libc_start_main_ret`. In vulnerable `set_exit_message` this address is `149*8` bytes ahead on stack, so we can access it with `%149p`.

Now we have to find `system` offset in libc. I tried to use this website https://libc.blukat.me/ but it didn't work (for remote binary).
The idea was to search for `libc` where `__libc_start_main_ret` is located at the address we got (modulo 0x1000), but this website doesn't seem to have libc which is used on picoCTF server (however it worked for my local version).

The last chance was to find the libc on our webshell (or different database).

```
> r2 /lib/x86_64-linux-gnu/libc.so.6                                   
[0x00021c50]> ?v sym.system
0x41490                                                                                  
```

So the system address is `0x41490`. Now we can overwrite `strtok` address with it and we get the shell. (I chose `strtok`, because it takes our input as the first argument and is called in every iteration)

[exploit](exploit.py) includes comments in first function, second one is analogical (please note that local mode doesn't have to work on your machine, you have to replace the offsets with the correct ones for your libc)

The flag is `ba2a70016347406c7a4bf920820a6112`.
