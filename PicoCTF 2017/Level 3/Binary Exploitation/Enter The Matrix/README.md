# Enter The Matrix

> The Matrix awaits you,. Take the red pill and begin your journey. Source. Jack in at shell2017.picoctf.com:19369.

Hints:

> Look carefully at how the matrix is indexed.

> Study the heap memory layout to see what you can overwrite.

When we have a look at the application, we can see that `print` command does not work. I don't know if it was intended, but we can solve the challenge without it.

```c
} else if(2 == sscanf(cmdbuf, "print %d", &id)) {
        handle_print(id);
```
According to Linux Programmer's Manual `On success, these functions return the number of input items successfully matched and assigned`, but we have only one parameter (so the function always returns 0 or 1 in this case).
We can patch it locally, but unfortunately server also runs version with this bug.

The code isn't too long, so we can analyze it quickly and hopefully find the vulnerability.
It appears that vulnerable functions are `handle_get` and `handle_set`.
```c
m->data[r * m->nrows + c] = v;
```
If number of rows is greater than number of columns we can read/write to arbitrary place in memory.
Let's assume 2x3 matrix. It would be printed like this.
```
0 1
2 3
4 5
```
However, if we want to write to `r=2 c=1` we'll get `r * m->nrows + c = 2*3+1=7`. Clearly we accessed the memory after our array.

```c
struct matrix {
    int nrows, ncols;
    float *data;
};
```
We can create two matrices, one rectangle and second one can be square (it doesn't matter). We'll use first one to overwrite data pointer of the second matrix. Then `get` and `set` commands will access memory of our choice.
We can overwrite some address in `.got.plt`, but which one is the best? We want to find a function that takes pointer to string we control as first argument. `handle_command` and `free` are the only function that comply with this requirement (note that there are no types in assembly, so we just need a pointer).
`handle_command` isn't dynamically loaded, so we can only choose `free`.

With radare2 on webshell we can obtain offsets we need. (`setbuf` is first entry in `.got.plt`)
```
$ r2 /lib32/libc.so.6  
[0x00019bc0]> ?v sym.setbuf
0x6b350
[0x00019bc0]> ?v sym.system
0x3e3e0
```

The last thing we have to do is to create third matrix with our string.

[exploit](exploit.py)

If you have problems with floats remember to use `%.9g` format, it should allow to represent it unambiguously (when I used `%f`, `%g` or `%e` it was encoded differently on server).

The flag is `56d46f10a5d2030c6c4a8ad4294c11fd`.