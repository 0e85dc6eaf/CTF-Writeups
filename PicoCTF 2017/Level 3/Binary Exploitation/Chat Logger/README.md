# Chat Logger

> You've been given admin access to the chat logs for our organization to help clean up the language. See if you can get a shell on shell2017.picoctf.com:33813. chat-logger Source

Hints:

> You should make some chat room log files to run this program locally.

> Learning about ptmalloc2 might help. glibc uses a modified version of it.

> Bear in mind that fopen allocates memory and fclose frees it.

Another difficult binary exploitation challenge. It took me way too much time to spot buffer overflow and the exploitation part was even worse.

The vulnerable function is
```c
void update_message(chat_message_t msg, char *new_text) {
    size_t len = strlen(new_text) + 1;
    if (len > msg->length) {
        msg->text = xrealloc(msg->text, normalize_size(len));
    }
    strncpy(msg->text+2, new_text, len);
    message_add_status(msg, '*');
}
```
Variable `len` contains our message size plus one, but `msg->length` also includes 2 bytes for message status. It gives us opportunity to overflow buffer by two bytes.

My first idea was to add two messages at the end of any chat. I hoped that they would be next to each other in the memory, so by overflowing the first one I could mark the second one as free. Then I could just expand the first message to overwrite `chat_message_t` structure of the other. `chat_message_t` contains pointer to the buffer, so I could put `.got.plt` address there and leak where `libc` was loaded.

Unfortunately the messages were put in some "random" places in memory. I thought that for some length of the buffers they would be written in a "correct" order, but I didn't manage to find such lengths.

Luckily first message buffer was just before its struct, so we could perform the attack using only one message (but I still had to send two messages, because otherwise the program was crashing for some mysterious reason).

To get offsets of libc functions we can use radare2 on the webshell.
```
system 0x41490
strtok 0x84a60
```
And with IDA we can find the address of `.got.plt` in the application.
```
strtok@.got.plt 601EC0
```
`strtok@.got.plt` address will become the need address of first message buffer. Please note that we need to subtract 2 from it, because the program puts `*	` on first two bytes and it would break our pointer (we can do this, because preceding pointer is useless - it's for `perror` function).

After overwriting the address we just need to type `/bin/sh` and we get the shell.

[Final exploit](exploit.py)

The flag is `bd4ce9661932e1a5a0fe2d51b61d0ecd`.
