# Flagsay 2

> Apparently I messed up using system(). I'm pretty sure this one is secure though! I hope flagsay-2 is just as exhilarating as the the first one! Source. Connect on shell2017.picoctf.com:46133.

Hints:

> The buffer isn't on the stack, so you can't use your own pointers. Is there another way to get a pointer?

> Make sure you know about using hn and $ in format strings

Another format string vulnerability.

```c
printf(tempFlag);
```

`tempFlag` contains our input and is passed as first argument to printf (alternatively we could read hints). Another nice thing is that we can use the vulnerability as many times as we want, because of the infinite loop used in the program.

Unfortunately the buffer isn't on stack and we have to find another way to put our pointers there.

From the previous challenges we know that looking for working libc in the Internet is pointless and we have to get the address from webshell.
```
$ r2 /lib32/libc.so.6
[0x00019bc0]> ?v sym.system
0x3e3e0
[0x00019bc0]> ?v sym.__libc_start_main
0x19970
```
11th element on stack is inside `__libc_start_main` (last three digits of address are `a63`), so its libc offset is `0x19a63`. We can also easily leak some stack pointers and build `.got.plt` pointer.

But which function we can overwrite? Initially I wanted to overwrite `strchr`, but it's not that easy. Format string vulnerability allows us to write 4 bytes at a time, but it would force server to send a few GB of data, so we can't really use it. Another option is to use `%hn`. It allows us to write 2 bytes (so up to 65kB of data), but unfortunately it's not enough to overwrite `strchr` pointer.
```
[0x00019bc0]> ?v sym.strchr
0x797f0                                                                                            
[0x00019bc0]> ?v sym.printf
0x4cc70                                                                                            
```
As we can see `printf` is much closer to `system`, but still it's not that close.
Eventually it appeared that we can use `printf`, but the exploit may fail.

[Final exploit](exploit.py) (usually works after around 10 retries)

The flag is `a57e404dd21b088391642bca70c312fd`.
