//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2020 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;

// ------------------------ Structures ------------------------

struct _EXCEPTION_POINTERS {
    struct _EXCEPTION_RECORD * e0;
    struct _CONTEXT * e1;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _IO_FILE {
    int32_t e0;
};

struct _LARGE_INTEGER {
    int64_t e0;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _LIST_ENTRY {
    struct _LIST_ENTRY * e0;
    struct _LIST_ENTRY * e1;
};

struct _M128A {
    int64_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int64_t e0;
    int64_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int64_t e15;
    int64_t e16;
    int64_t e17;
    int64_t e18;
    int64_t e19;
    int64_t e20;
    int64_t e21;
    int64_t e22;
    int64_t e23;
    int64_t e24;
    int64_t e25;
    int64_t e26;
    int64_t e27;
    int64_t e28;
    int64_t e29;
    int64_t e30;
    int64_t e31;
    int64_t e32;
    int64_t e33;
    int64_t e34;
    int64_t e35;
    int64_t e36;
    int64_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int64_t e40;
    int64_t e41;
    int64_t e42;
    int64_t e43;
    int64_t e44;
    int64_t e45;
};

struct _MEMORY_BASIC_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct _RTL_CRITICAL_SECTION {
    struct _RTL_CRITICAL_SECTION_DEBUG * e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
    int32_t * e4;
    int32_t e5;
};

struct _RTL_CRITICAL_SECTION_DEBUG {
    int16_t e0;
    int16_t e1;
    struct _RTL_CRITICAL_SECTION * e2;
    struct _LIST_ENTRY e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int16_t e7;
    int16_t e8;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct _WIN32_FIND_DATAA {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    char e8[1];
    char e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct anon_struct_3 {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t ___chkstk_ms(void);
int32_t (*___dllonexit(int32_t (*func)(), void (***pbegin)(), void (***pend)()))();
int32_t ___getmainargs(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo);
void ___set_app_type(int32_t at);
void ___setusermatherr(int32_t pf);
int32_t ___w64_mingwthr_add_key_dtor(int32_t key, void (*dtor)(char *));
int32_t ___w64_mingwthr_remove_key_dtor(int32_t key);
void __amsg_exit(int32_t rterrnum);
void __cexit(void);
void __do_global_ctors(void);
void __do_global_dtors(void);
int32_t __dyn_tls_dtor(char * hDllHandle, int32_t dwReason, char * lpreserved);
void __dyn_tls_init_40_12(char * hDllHandle, int32_t dwReason, char * lpreserved);
void __initterm(void (**First)(), void (**Last)());
void __lock(int32_t locknum);
void __main(void);
char * __mingw_enum_import_library_names(int32_t i);
int32_t __mingw_GetSectionCount(void);
int32_t __mingw_GetSectionForAddress(char * p);
void __mingw_invalidParameterHandler(int16_t * expression, int16_t * function, int16_t * file, int32_t line, int32_t pReserved);
void __mingw_raise_matherr(int32_t typ, char * name, float64_t a1, float64_t a2, float64_t rslt);
void __mingw_setusermatherr(int32_t f);
int32_t __mingw_TLScallback(char * hDllHandle, int32_t reason, char * reserved);
void __mingwthr_run_key_dtors(void);
void __report_error(char * msg, ...);
void __report_gsfailure(int32_t StackCookie);
void __security_init_cookie(void);
int32_t __tlregdtor(void (*func)());
int32_t __tmainCRTStartup(void);
void __unlock(int32_t locknum);
int32_t __ValidateImageBase_part_0(void);
void _abort(void);
int32_t * _calloc(int32_t nmemb, int32_t size);
int32_t _decode(void);
char * _decode_pointer(char * codedptr);
int32_t _decodeBytes(int32_t lpFileName);
int32_t _DoNotUpdateLastAccessTime(int32_t hFile);
char * _encode_pointer(char * ptr);
int32_t _encodeBytes(int32_t a1, int32_t a2, int32_t * a3);
void _exit(int32_t status);
int32_t _FindPESection(char * pImageBase, uint32_t rva);
int32_t _FindPESectionByName(char * pName);
int32_t _FindPESectionExec(int32_t eNo);
struct _IO_FILE * _fopen(char * filename, char * modes);
void _fpreset(void);
int32_t _fprintf(struct _IO_FILE * stream, char * format, ...);
int32_t _fread(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream);
void _free(int32_t * ptr);
int32_t _fwrite(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s);
char * _GetPEImageBase(void);
int32_t _gnu_exception_handler_40_4(int32_t exception_data);
int32_t _hideInFile(int32_t lpFileName);
int32_t _IsNonwritableInCurrentImage(char * pTarget);
int32_t _listdir(int32_t a1, int32_t a2);
int32_t * _malloc(int32_t size);
int32_t _matherr(int32_t pexcept);
int32_t * _memcpy(int32_t * dest, int32_t * src, int32_t n);
void _pei386_runtime_relocator(void);
int32_t _printf(char * format, ...);
int32_t _puts(char * s);
int32_t _setargv(void);
void (*_signal(int32_t sig, void (*handler2)(int32_t)))(int32_t);
int32_t _sprintf(char * s, char * format, ...);
int32_t _strcmp(char * s1, char * s2);
int32_t _strlen(char * s);
int32_t _strncmp(char * s1, char * s2, int32_t n);
void _ValidateImageBase(char * pImageBase);
int32_t _vfprintf(struct _IO_FILE * s, char * format, int32_t arg);
int32_t function_402191(void);
int32_t mainCRTStartup(void);
void mark_section_writable(char * addr);
void (*mingw_get_invalid_parameter_handler(void))(int16_t *, int16_t *, int16_t *, int32_t, int32_t);
int32_t (*mingw_onexit(int32_t (*func)()))();
void (*mingw_set_invalid_parameter_handler(void (*new_handler)(int16_t *, int16_t *, int16_t *, int32_t, int32_t)))(int16_t *, int16_t *, int16_t *, int32_t, int32_t);
int32_t my_lconv_init(void);
int32_t pre_c_init(void);
void pre_cpp_init(void);
int32_t sleep(int32_t seconds);
int32_t WinMainCRTStartup(void);

// --------------------- Global Variables ---------------------

int32_t GS_ExceptionPointers = 0x405380;
int32_t GS_ExceptionRecord = 0;
int32_t _CRT_MT = 2;
int32_t _MINGW_INSTALL_DEBUG_MATHERR = -1;
int32_t __mingw_oldexcpt_handler = 0;
int32_t __mingw_winmain_hInstance = 0;
int32_t __mingw_winmain_lpCmdLine = 0;
int32_t __mingw_winmain_nShowCmd = 10;
int32_t __mingwthr_cs = 0;
int32_t __mingwthr_cs_init = 0;
int32_t __native_startup_lock = 0;
int32_t __native_startup_state = 0;
void (**__onexitbegin)() = NULL;
void (**__onexitend)() = NULL;
int32_t __security_cookie = -0x44bf19b2;
int32_t __security_cookie_complement = 0x44bf19b1;
void (*__xc_a[1])();
void (*__xc_z[1])();
void (*__xi_a[1])();
void (*__xi_z[1])();
int32_t _dowildcard = 0;
int32_t _fmode = 0;
int32_t _newmode = 0;
int32_t argc = 0;
int32_t argret = 0;
char ** argv = NULL;
int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // edi
char ** envp = NULL;
int32_t g5 = 0; // esi
int32_t g6 = 0; // esp
char * g7 = "\x83\xec\x3c\xb9\x3c\x41\x40";
int32_t g8 = 0x402e64;
int32_t g9 = 0x2e2e002e;
struct _FILETIME * g10 = (struct _FILETIME *)-1;
char * g11[6] = {
    "Argument domain error (DOMAIN)",
    "Argument singularity (SIGN)",
    "Overflow range error (OVERFLOW)",
    "The result is too small to be represented (UNDERFLOW)",
    "Total loss of significance (TLOSS)",
    "Partial loss of significance (PLOSS)"
};
int32_t g12 = 0;
int32_t g13 = 0;
int32_t g14 = 0;
int32_t g15 = 0;
int32_t g16 = 0;
char * g17;
int32_t g18 = 0;
int32_t g19 = 0;
char * g20;
char * g21;
int32_t g22 = 0;
char g23 = 0;
int32_t g24 = 0;
int32_t g25 = 0;
int32_t g26 = 0x647a;
void (*handler)(int16_t *, int16_t *, int16_t *, int32_t, int32_t) = NULL;
int32_t has_cctor = 0;
int32_t initialized = 0;
int32_t key_dtor_list = 0;
int32_t mainret = 0;
int32_t managedapp = 0;
int32_t maxSections = 0;
int32_t mingw_app_type = 0;
int32_t mingw_initcharmax = 0;
int32_t mingw_initltsdrot_force = 0;
int32_t mingw_initltsdyn_force = 0;
int32_t mingw_initltssuo_force = 0;
int32_t stUserMathErr = 0;
struct anon_struct_3 startinfo = {
    .e0 = 0
};
int32_t the_secs = 0;
int32_t g27;

// ------------------------ Functions -------------------------

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x401000 - 0x401002
// Line range:    113 - 118
void __mingw_invalidParameterHandler(int16_t * expression, int16_t * function, int16_t * file, int32_t line, int32_t pReserved) {
    // 0x401000
    return;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x401010 - 0x40112e
// Line range:    126 - 376
int32_t pre_c_init(void) {
    // 0x401010
    mingw_initltsdrot_force = 1;
    mingw_initltsdyn_force = 1;
    mingw_initltssuo_force = 1;
    mingw_initcharmax = 1;
    bool v1;
    if (*(int16_t *)0x400000 == 0x5a4d) {
        int32_t v2 = *(int32_t *)0x40003c; // 0x4010b0
        if (*(int32_t *)(v2 + 0x400000) == 0x4550) {
            int16_t v3 = *(int16_t *)(v2 + 0x400018); // 0x4010c8
            if (v3 == 267) {
                // 0x401112
                if (*(int32_t *)(v2 + 0x400074) >= 15) {
                    // 0x40111c
                    v1 = *(int32_t *)(v2 + 0x4000e8) != 0;
                } else {
                    v1 = false;
                }
            } else {
                if (v3 == 523) {
                    // 0x4010de
                    if (*(int32_t *)(v2 + 0x400084) >= 15) {
                        // 0x4010eb
                        v1 = *(int32_t *)(v2 + 0x4000f8) != 0;
                    } else {
                        v1 = false;
                    }
                } else {
                    v1 = false;
                }
            }
        } else {
            v1 = false;
        }
    } else {
        v1 = false;
    }
    // 0x401048
    managedapp = v1;
    if (mingw_app_type == 0) {
        // 0x4010a0
        __set_app_type(1);
    } else {
        // 0x401056
        __set_app_type(2);
    }
    int32_t v4 = (int32_t)_encode_pointer((char *)-1); // 0x401069
    *(int32_t *)&__onexitend = v4;
    *(int32_t *)&__onexitbegin = v4;
    *(int32_t *)*(int32_t *)0x4061c0 = _fmode;
    _setargv();
    if (_MINGW_INSTALL_DEBUG_MATHERR != 1) {
        // 0x401093
        return 0;
    }
    // 0x401100
    __mingw_setusermatherr((int32_t)&g7);
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x401130 - 0x401173
// Line range:    155 - 164
void pre_cpp_init(void) {
    struct anon_struct_3 v1; // bp-28
    // 0x401130
    v1 = (struct {int32_t e0;}){
        .e0 = (int32_t)&startinfo
    };
    startinfo.e0 = _newmode;
    argret = __getmainargs(&argc, &argv, &envp, _dowildcard, (int32_t *)v1.e0);
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x401180 - 0x4014b3
// Line range:    222 - 335
int32_t __tmainCRTStartup(void) {
    // 0x401180
    int32_t v1; // bp-96
    __asm_rep_stosd_memset((char *)&v1, 0, 17);
    g1 = 48;
    int32_t v2 = g6 - ___chkstk_ms() + 27 & -16; // 0x4011a4
    *(int32_t *)v2 = -0x33333334;
    *(int32_t *)(v2 + 4) = -0x33333334;
    *(int32_t *)(v2 + 8) = -0x33333334;
    *(int32_t *)(v2 + 12) = -0x33333334;
    *(int32_t *)(v2 + 16) = -0x33333334;
    *(int32_t *)(v2 + 20) = -0x33333334;
    *(int32_t *)(v2 + 24) = -0x33333334;
    *(int32_t *)(v2 + 28) = -0x33333334;
    if (mingw_app_type != 0) {
        // 0x401470
        *(int32_t *)(g6 & -16) = (int32_t)&v1;
        GetStartupInfoA((struct _STARTUPINFOA *)&g27);
    }
    int32_t v3 = __readfsdword(24); // 0x4011ef
    g5 = 0;
    int32_t v4 = *(int32_t *)(v3 + 4); // 0x4011f7
    g4 = *(int32_t *)0x406180;
    int32_t v5 = __native_startup_lock; // 0x40121868
    __native_startup_lock = v5 == 0 ? v4 : v5;
    int32_t v6; // 0x401411
    if (v5 != 0) {
        while (true) {
            if (v5 == v4) {
                // break -> 0x401411
                break;
            }
            // 0x40120a
            *(int32_t *)g6 = 1000;
            Sleep((int32_t)&g27);
            int32_t v7 = __native_startup_lock; // 0x401218
            __native_startup_lock = g5 == v7 ? v4 : v7;
            if (v7 == 0) {
                goto lab_0x401224;
            }
            v5 = v7;
        }
        // 0x401411
        v6 = __native_startup_state;
        g3 = 1;
        if (v6 != 1) {
            goto lab_0x401234;
        } else {
            goto lab_0x401424;
        }
    } else {
        goto lab_0x401224;
    }
  lab_0x401224:;
    int32_t v8 = __native_startup_state; // 0x401224
    g3 = 0;
    if (v8 == 1) {
        goto lab_0x401424;
    } else {
        v6 = v8;
        goto lab_0x401234;
    }
  lab_0x401304:;
    // 0x401304
    int32_t v9; // 0x401304
    v9++;
    char v10 = *(char *)v9; // 0x401307
    if (v10 > 32 || v10 == 0) {
        // 0x40130f
        __mingw_winmain_lpCmdLine = v9;
        goto lab_0x401314;
    } else {
        goto lab_0x401304;
    }
  lab_0x401234:;
    // 0x401234
    int32_t v11; // 0x40124b
    if (v6 == 0) {
        // 0x401481
        __native_startup_state = 1;
        *(int32_t *)(g6 + 4) = (int32_t)&__xi_z;
        *(int32_t *)g6 = (int32_t)&__xi_a;
        _initterm((void (**)())&g27, (void (**)())&g27);
        v11 = __native_startup_state;
    } else {
        // 0x401241
        has_cctor = 1;
        v11 = v6;
    }
    // 0x40124b
    if (v11 == 1) {
        goto lab_0x40143e;
    } else {
        goto lab_0x401259;
    }
  lab_0x401424:
    // 0x401424
    *(int32_t *)g6 = 31;
    _amsg_exit((int32_t)&g27);
    if (__native_startup_state != 1) {
        goto lab_0x401259;
    } else {
        goto lab_0x40143e;
    }
  lab_0x40143e:
    // 0x40143e
    *(int32_t *)(g6 + 4) = (int32_t)&__xc_z;
    *(int32_t *)g6 = (int32_t)&__xc_a;
    _initterm((void (**)())&g27, (void (**)())&g27);
    int32_t v12 = g3; // 0x401452
    __native_startup_state = 2;
    if (v12 != 0) {
        goto lab_0x401261;
    } else {
        goto lab_0x401464;
    }
  lab_0x401259:
    // 0x401259
    if (g3 == 0) {
        v12 = 0;
        goto lab_0x401464;
    } else {
        goto lab_0x401261;
    }
  lab_0x401261:
    // 0x401261
    *(int32_t *)(g6 + 8) = 0;
    *(int32_t *)(g6 + 4) = 2;
    *(int32_t *)g6 = 0;
    __dyn_tls_init_40_12((char *)&g27, (int32_t)&g27, (char *)&g27);
    _pei386_runtime_relocator();
    *(int32_t *)g6 = 0x401ed0;
    __mingw_oldexcpt_handler = (int32_t)SetUnhandledExceptionFilter((int32_t (*)(struct _EXCEPTION_POINTERS *))&g27);
    *(int32_t *)(g6 - 4) = 0x401000;
    mingw_set_invalid_parameter_handler((void (*)(int16_t *, int16_t *, int16_t *, int32_t, int32_t))&g27);
    _fpreset();
    __mingw_winmain_hInstance = 0x400000;
    if (g26 == 0) {
        goto lab_0x401314;
    } else {
        int32_t v13 = 0; // 0x4012f1
        int32_t v14 = g26; // 0x4012de
        while (true) {
            char v15 = *(char *)v14; // 0x4012e1
            int32_t v16;
            if (v15 > 32) {
                // 0x4012e9
                v16 = v15 == 34 ? v13 ^ 1 : v13;
            } else {
                if (v15 == 0) {
                    // break -> 0x40130f
                    break;
                }
                // 0x4012d4
                if (v13 % 2 == 0) {
                    v9 = v14;
                    goto lab_0x401304;
                }
                v16 = 1;
            }
            // 0x4012de
            v13 = v16;
            v14++;
        }
        // 0x40130f
        __mingw_winmain_lpCmdLine = v14;
        goto lab_0x401314;
    }
  lab_0x401464:;
    int32_t v17 = __native_startup_lock; // 0x401464
    __native_startup_lock = v12;
    g3 = v17;
    goto lab_0x401261;
  lab_0x401314:
    // 0x401314
    g3 = mingw_app_type;
    if (mingw_app_type != 0) {
        // 0x40131e
        unsigned char v18;
        uint16_t v19;
        __mingw_winmain_nShowCmd = v18 % 2 != 0 ? (int32_t)v19 : 10;
    }
    int32_t v20 = argc; // 0x401333
    int32_t v21 = 4 * v20; // 0x40133d
    int32_t size = v21 + 4; // 0x40133d
    *(int32_t *)g6 = size;
    int32_t mem = (int32_t)malloc(size); // 0x40134a
    int32_t v22 = *(int32_t *)&argv; // 0x401354
    if (v20 >= 1) {
        // 0x401360
        g3 = 0;
        *(int32_t *)g6 = *(int32_t *)v22;
        int32_t v23 = strlen((char *)&g27) + 1; // 0x40136f
        *(int32_t *)g6 = v23;
        int32_t mem2 = (int32_t)malloc((int32_t)&g27); // 0x401375
        *(int32_t *)(4 * g3 + mem) = mem2;
        int32_t v24 = g3; // 0x401380
        g3 = v24 + 1;
        *(int32_t *)(g6 + 8) = v23;
        *(int32_t *)g6 = mem2;
        *(int32_t *)(g6 + 4) = *(int32_t *)(4 * v24 + v22);
        memcpy(&g27, &g27, (int32_t)&g27);
        while (g3 != v20) {
            // 0x401364
            *(int32_t *)g6 = *(int32_t *)(4 * g3 + v22);
            v23 = strlen((char *)&g27) + 1;
            *(int32_t *)g6 = v23;
            mem2 = (int32_t)malloc((int32_t)&g27);
            *(int32_t *)(4 * g3 + mem) = mem2;
            v24 = g3;
            g3 = v24 + 1;
            *(int32_t *)(g6 + 8) = v23;
            *(int32_t *)g6 = mem2;
            *(int32_t *)(g6 + 4) = *(int32_t *)(4 * v24 + v22);
            memcpy(&g27, &g27, (int32_t)&g27);
        }
    } else {
        v21 = 0;
    }
    // 0x4013a1
    *(int32_t *)(v21 + mem) = 0;
    *(int32_t *)&argv = mem;
    __main();
    *(int32_t *)0x6438 = *(int32_t *)&envp;
    *(int32_t *)(g6 + 8) = *(int32_t *)&envp;
    *(int32_t *)(g6 + 4) = *(int32_t *)&argv;
    *(int32_t *)g6 = argc;
    int32_t v25 = main((int32_t)&g27, (char **)&g27); // 0x4013dd
    mainret = v25;
    if (managedapp == 0) {
        // 0x4014ab
        *(int32_t *)g6 = v25;
        exit((int32_t)&g27);
        // UNREACHABLE
    }
    // 0x4013f5
    int32_t result; // 0x401410
    if (has_cctor == 0) {
        // 0x4013ff
        _cexit();
        result = mainret;
    } else {
        result = v25;
    }
    // 0x401409
    return result;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x4014c0 - 0x4014da
// Line range:    170 - 184
int32_t WinMainCRTStartup(void) {
    // 0x4014c0
    mingw_app_type = 1;
    __security_init_cookie();
    return __tmainCRTStartup();
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crtexe.c
// Address range: 0x4014e0 - 0x4014fa
// Line range:    198 - 212
int32_t mainCRTStartup(void) {
    // 0x4014e0
    mingw_app_type = 0;
    __security_init_cookie();
    return __tmainCRTStartup();
}

// Address range: 0x401500 - 0x401530
int32_t _DoNotUpdateLastAccessTime(int32_t hFile) {
    bool result = SetFileTime((int32_t *)hFile, NULL, (struct _FILETIME *)&g10, NULL); // 0x401529
    return result;
}

// Address range: 0x401530 - 0x401573
int32_t _encodeBytes(int32_t a1, int32_t a2, int32_t * a3) {
    // 0x401530
    *a3 = 256 * a1 + a2 + (*a3 & -0x10000);
    return (int32_t)a3;
}

// Address range: 0x401573 - 0x4016fb
int32_t _decodeBytes(int32_t lpFileName) {
    int32_t * fileHandle = CreateFileA((char *)lpFileName, 128, 0, NULL, 3, 0, NULL); // 0x4015b4
    _DoNotUpdateLastAccessTime((int32_t)fileHandle);
    if (fileHandle == (int32_t *)-1) {
        // 0x4016f9
        return printf("error loading the file");
    }
    // 0x4015de
    int32_t lpCreationTime; // bp-36
    int32_t lpLastAccessTime; // bp-44
    int32_t lpLastWriteTime; // bp-52
    bool v1 = GetFileTime(fileHandle, (struct _FILETIME *)&lpCreationTime, (struct _FILETIME *)&lpLastAccessTime, (struct _FILETIME *)&lpLastWriteTime); // 0x4015fe
    if (!v1) {
        // 0x4016f9
        return printf("error getting the times of the file");
    }
    uint32_t v2 = 0x1000000 * lpLastWriteTime / 0x1000000 / 256; // bp-64
    int32_t v3 = 2 * g22 + 2; // 0x40168a
    if (v3 > 0) {
        int32_t v4 = 0; // 0x4016ca20
        while (true) {
            int32_t * v5 = (int32_t *)g18; // 0x4016d7
            if (*v5 >= g24) {
                // break -> 0x4016e2
                break;
            }
            char v6 = *(char *)(v4 + (int32_t)&v2); // 0x4016af
            *(char *)(*v5 + (int32_t)g21) = v6;
            int32_t * v7 = (int32_t *)g18; // 0x4016bf
            *v7 = *v7 + 1;
            int32_t v8 = v4 + 1; // 0x4016c6
            if (v8 >= v3) {
                // break -> 0x4016e2
                break;
            }
            v4 = v8;
        }
    }
    // 0x4016e2
    if (*(int32_t *)g18 >= g24) {
        // 0x4016f2
        g23 = 1;
    }
    // 0x4016f9
    return g24;
}

// Address range: 0x4016fb - 0x401957
int32_t _hideInFile(int32_t lpFileName) {
    int32_t * fileHandle = CreateFileA((char *)lpFileName, 256, 0, NULL, 3, 0, NULL); // 0x40173c
    _DoNotUpdateLastAccessTime((int32_t)fileHandle);
    if (fileHandle == (int32_t *)-1) {
        // 0x401955
        return printf("Error:INVALID_HANDLED_VALUE");
    }
    // 0x401766
    int32_t lpCreationTime; // bp-28
    int32_t lpLastAccessTime; // bp-36
    int32_t lpLastWriteTime; // bp-44
    bool v1 = GetFileTime(fileHandle, (struct _FILETIME *)&lpCreationTime, (struct _FILETIME *)&lpLastAccessTime, (struct _FILETIME *)&lpLastWriteTime); // 0x401786
    if (!v1) {
        // 0x401955
        return printf("Error: C-GFT-01");
    }
    int32_t * v2 = (int32_t *)g25; // 0x4017b3
    int32_t v3 = *v2; // 0x4017b3
    char v4 = *(char *)(v3 + (int32_t)g20); // 0x4017b7
    *v2 = v3 + 1;
    int32_t * v5 = (int32_t *)g25; // 0x4017da
    int32_t v6 = *v5; // 0x4017da
    char v7 = *(char *)(v6 + (int32_t)g20); // 0x4017de
    *v5 = v6 + 1;
    _encodeBytes((int32_t)v4, (int32_t)v7, &lpLastWriteTime);
    if (g22 >= 1) {
        int32_t * v8 = (int32_t *)g25; // 0x401825
        int32_t v9 = *v8; // 0x401825
        char v10 = *(char *)(v9 + (int32_t)g20); // 0x401829
        *v8 = v9 + 1;
        int32_t * v11 = (int32_t *)g25; // 0x40184c
        int32_t v12 = *v11; // 0x40184c
        char v13 = *(char *)(v12 + (int32_t)g20); // 0x401850
        *v11 = v12 + 1;
        _encodeBytes((int32_t)v10, (int32_t)v13, &lpCreationTime);
        if (g22 == 2) {
            int32_t * v14 = (int32_t *)g25; // 0x401898
            int32_t v15 = *v14; // 0x401898
            char v16 = *(char *)(v15 + (int32_t)g20); // 0x40189c
            *v14 = v15 + 1;
            int32_t * v17 = (int32_t *)g25; // 0x4018bf
            int32_t v18 = *v17; // 0x4018bf
            char v19 = *(char *)(v18 + (int32_t)g20); // 0x4018c3
            *v17 = v18 + 1;
            _encodeBytes((int32_t)v16, (int32_t)v19, &lpLastAccessTime);
        }
    }
    bool v20 = SetFileTime(fileHandle, (struct _FILETIME *)&lpCreationTime, (struct _FILETIME *)&lpLastAccessTime, (struct _FILETIME *)&lpLastWriteTime); // 0x401916
    if (!v20) {
        // 0x401955
        return printf("Error: C-SFT-01");
    }
    // 0x40192d
    if (*(int32_t *)g25 >= g19) {
        // 0x40193d
        g23 = 1;
    }
    // 0x401955
    return CloseHandle(fileHandle);
}

// Address range: 0x401957 - 0x401afe
int32_t _listdir(int32_t a1, int32_t a2) {
    // 0x401957
    int32_t str; // bp-2392
    int32_t v1 = &str; // 0x401976
    char * v2 = (char *)a2; // 0x40197f
    sprintf((char *)&str, "%s\\*.*", v2);
    int32_t lpFindFileData; // bp-344
    int32_t * v3 = FindFirstFileA((char *)&str, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x40199c
    int32_t v4 = (int32_t)v3; // 0x40199c
    char * v5; // bp-2420
    if (v3 == (int32_t *)-1) {
        // 0x4019aa
        v5 = "Path not found: [%s]\n";
        // 0x401afc
        return printf("Path not found: [%s]\n", v2);
    }
    // 0x401ae2
    int32_t v6; // bp-300
    int32_t v7 = &v6; // 0x4019e0
    int32_t v8 = (int32_t)&v5; // 0x4019d2
    int32_t str2 = 1;
    int32_t v9 = 1;
    int32_t v10; // 0x401aef
    while (true) {
        // 0x4019d2
        *(int32_t *)(v8 + 4) = (int32_t)&g9;
        *(int32_t *)g6 = v7;
        int32_t v11;
        if (strcmp((char *)str2, (char *)&g27) != 0) {
            // 0x4019f3
            *(int32_t *)(g6 + 4) = (int32_t)"..";
            *(int32_t *)g6 = v7;
            if (strcmp((char *)&g27, (char *)&g27) != 0) {
                // 0x401a14
                *(int32_t *)(g6 + 12) = v7;
                *(int32_t *)(g6 + 8) = a2;
                *(int32_t *)(g6 + 4) = (int32_t)"%s\\%s";
                *(int32_t *)g6 = v1;
                sprintf((char *)&g27, (char *)&g27);
                if ((lpFindFileData & 16) == 0) {
                    if (v9 == 1) {
                        if (a1 != 0) {
                            if (a1 == 1) {
                                // 0x401a9a
                                *(int32_t *)g6 = v1;
                                _decodeBytes((int32_t)&g27);
                            }
                        } else {
                            // 0x401a84
                            *(int32_t *)g6 = v1;
                            _hideInFile((int32_t)&g27);
                        }
                    }
                    // 0x401aa8
                    v11 = 1 - v9;
                } else {
                    // 0x401a4b
                    *(int32_t *)(g6 + 4) = v1;
                    *(int32_t *)g6 = (int32_t)"Folder: %s\n";
                    printf((char *)&g27);
                    *(int32_t *)(g6 + 4) = v1;
                    *(int32_t *)g6 = a1;
                    _listdir((int32_t)&g27, (int32_t)&g27);
                    v11 = v9;
                }
            } else {
                v11 = v9;
            }
        } else {
            v11 = v9;
        }
        // 0x401ab3
        if (g23 != 0) {
            v10 = g6;
            // break -> 0x401aec
            break;
        }
        // 0x401ac0
        *(int32_t *)(g6 + 4) = (int32_t)&lpFindFileData;
        *(int32_t *)g6 = v4;
        bool v12 = FindNextFileA(&g27, (struct _WIN32_FIND_DATAA *)&g27); // 0x401ad5
        int32_t v13 = g6 - 8; // 0x401ad7
        if (!v12) {
            v10 = v13;
            // break -> 0x401aec
            break;
        }
        v8 = v13;
        str2 = v12;
        v9 = v11;
    }
    // 0x401aec
    *(int32_t *)v10 = v4;
    // 0x401afc
    return FindClose(&g27);
}

// Address range: 0x401afe - 0x401b9c
int32_t _decode(void) {
    int32_t v1 = 0x616c6f68; // bp-36
    g24 = 18;
    int32_t v2 = 0; // bp-40
    g21 = (char *)&v1;
    g18 = &v2;
    _listdir(1, (int32_t)g17);
    printf("value of DECODE %s \n", g21);
    puts("Wait for 5 seconds to exit.");
    sleep(5);
    exit(0);
    return &g27;
}

// Address range: 0x401b9c - 0x401cdb
int main(int argc2, char ** argv2) {
    // 0x401b9c
    __main();
    g23 = 0;
    int32_t v1 = 0x65742f2e; // bp-40
    g17 = (char *)&v1;
    g22 = 0;
    struct _IO_FILE * file = fopen("flag.txt", "r"); // 0x401c20
    if (file == NULL) {
        // 0x401c30
        puts("No flag found, please make sure this is run on the server");
    }
    // 0x401c3c
    int32_t data; // bp-90
    int32_t items_read = fread(&data, 1, 18, file); // 0x401c5b
    if (items_read >= 0 != items_read != 0) {
        // 0x401c6b
        exit(0);
        // UNREACHABLE
    }
    // 0x401c77
    g20 = (char *)&data;
    g19 = 18;
    int32_t v2 = 0; // bp-96
    g25 = &v2;
    puts("Work is done!");
    _listdir(0, (int32_t)g17);
    puts("Wait for 5 seconds to exit.");
    sleep(5);
    return 2;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlssup.c
// Address range: 0x401ce0 - 0x401d23
// Line range:    142 - 174
int32_t __dyn_tls_dtor(char * hDllHandle, int32_t dwReason, char * lpreserved) {
    switch (dwReason) {
        case 0: {
        }
        case 3: {
            // 0x401d00
            __mingw_TLScallback(hDllHandle, dwReason, lpreserved);
            return 1;
        }
    }
    // 0x401cf0
    return 1;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlssup.c
// Address range: 0x401d30 - 0x401dae
// Line range:    82 - 94
void __dyn_tls_init_40_12(char * hDllHandle, int32_t dwReason, char * lpreserved) {
    // 0x401d30
    if (_CRT_MT != 2) {
        // 0x401d41
        _CRT_MT = 2;
    }
    switch (dwReason) {
        case 2: {
            // break -> 0x401d55
            break;
        }
        case 1: {
            // 0x401d90
            __mingw_TLScallback(hDllHandle, 1, lpreserved);
            // break -> 0x401d55
            break;
        }
    }
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlssup.c
// Address range: 0x401db0 - 0x401db3
// Line range:    115 - 139
int32_t __tlregdtor(void (*func)()) {
    // 0x401db0
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/charmax.c
// Address range: 0x401dc0 - 0x401dc7
// Line range:    16 - 18
int32_t my_lconv_init(void) {
    // 0x401dc0
    return __lconv_init();
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/mingw_helpers.c
// Address range: 0x401dd0 - 0x401dd5
// Line range:    19 - 22
char * _decode_pointer(char * codedptr) {
    // 0x401dd0
    return codedptr;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/mingw_helpers.c
// Address range: 0x401de0 - 0x401de5
// Line range:    25 - 28
char * _encode_pointer(char * ptr) {
    // 0x401de0
    return ptr;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/atonexit.c
// Address range: 0x401df0 - 0x401ea2
// Line range:    33 - 53
int32_t (*mingw_onexit(int32_t (*func)()))() {
    char * v1 = _decode_pointer((char *)*(int32_t *)&__onexitbegin); // 0x401dfc
    void (**onexitend)() = (void (**)())v1; // bp-20
    if (v1 == (char *)-1) {
        // 0x401e90
        return _onexit(func);
    }
    // 0x401e0e
    _lock(8);
    onexitend = (void (**)())_decode_pointer((char *)*(int32_t *)&__onexitbegin);
    int32_t v2 = (int32_t)_decode_pointer((char *)*(int32_t *)&__onexitend); // bp-16
    int32_t (*v3)() = __dllonexit(func, &onexitend, (void (***)())&v2); // 0x401e53
    *(int32_t *)&__onexitbegin = (int32_t)_encode_pointer((char *)onexitend);
    *(int32_t *)&__onexitend = (int32_t)_encode_pointer((char *)v2);
    _unlock(8);
    return (int32_t (*)())(int32_t)v3;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/crt_handler.c
// Address range: 0x401ed0 - 0x402069
// Line range:    194 - 261
int32_t _gnu_exception_handler_40_4(int32_t exception_data) {
    uint32_t v1 = *(int32_t *)*(int32_t *)exception_data; // 0x401edc
    void (*prev_sig_handler)(int32_t); // 0x401f6f
    if (v1 < 0xc0000092) {
        if (v1 >= 0xc000008d) {
            goto lab_0x401fa0;
        } else {
            if (v1 != -0x3ffffffb) {
                if (v1 != -0x3fffffe3) {
                    goto lab_0x401f49;
                } else {
                    goto lab_0x401fdf;
                }
            } else {
                // 0x401efb
                switch ((int32_t)v2) {
                    case 1: {
                        // 0x402030
                        signal(SIGSEGV, SIG_IGN);
                        // 0x401f8f
                        return -1;
                    }
                    case 0: {
                        goto lab_0x401f49;
                    }
                    default: {
                        // 0x401f8f
                        return -1;
                    }
                }
            }
        }
    } else {
        switch (v1) {
            case -0x3fffff6c: {
                // 0x401f60
                prev_sig_handler = signal(SIGFPE, SIG_DFL);
                if (prev_sig_handler == (void (*)(int32_t))1) {
                    // 0x402050
                    signal(SIGFPE, SIG_IGN);
                    // 0x401f8f
                    return -1;
                }
                goto lab_0x401f7d;
            }
            case -0x3fffff6a: {
                goto lab_0x401fdf;
            }
            case -0x3fffff6d: {
                goto lab_0x401fa0;
            }
            default: {
                goto lab_0x401f49;
            }
        }
    }
  lab_0x401fa0:;
    void (*prev_sig_handler2)(int32_t) = signal(SIGFPE, SIG_DFL); // 0x401faf
    if (prev_sig_handler2 == (void (*)(int32_t))1) {
        // 0x401fb9
        signal(SIGFPE, SIG_IGN);
        _fpreset();
        // 0x401f8f
        return -1;
    }
    prev_sig_handler = prev_sig_handler2;
    goto lab_0x401f7d;
  lab_0x401fdf:
    // 0x401fdf
    switch ((int32_t)v3) {
        case 1: {
            // 0x402010
            signal(SIGILL, SIG_IGN);
            // 0x401f8f
            return -1;
        }
        case 0: {
            goto lab_0x401f49;
        }
        default: {
            // 0x401f8f
            return -1;
        }
    }
  lab_0x401f49:
    // 0x401f49
    if (__mingw_oldexcpt_handler != 0) {
        // 0x401f52
        return __mingw_oldexcpt_handler;
    }
    // 0x401f8f
    return 0;
  lab_0x401f7d:
    if (prev_sig_handler != NULL) {
        // 0x401f8f
        return -1;
    }
    goto lab_0x401f49;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/dllargv.c
// Address range: 0x402070 - 0x402073
// Line range:    18 - 22
int32_t _setargv(void) {
    // 0x402070
    return 0;
}

// From module:   C:/crossdev/gccmaster/host-toolchain-tdm64/x86_64-w64-mingw32/include/math.h
// Address range: 0x402080 - 0x4020cb
// Line range:    176 - 26
void __mingw_raise_matherr(int32_t typ, char * name, float64_t a1, float64_t a2, float64_t rslt) {
}

// From module:   C:/crossdev/gccmaster/host-toolchain-tdm64/x86_64-w64-mingw32/include/math.h
// Address range: 0x4020d0 - 0x4020de
// Line range:    178 - 33
void __mingw_setusermatherr(int32_t f) {
    // 0x4020d0
    stUserMathErr = f;
    __setusermatherr((int32_t)&g27);
}

// From module:   C:/crossdev/gccmaster/host-toolchain-tdm64/x86_64-w64-mingw32/include/math.h
// Address range: 0x4020e0 - 0x40213b
// Line range:    282 - 75
int32_t _matherr(int32_t pexcept) {
    uint32_t v1 = *(int32_t *)pexcept - 1; // 0x4020ee
    int32_t v2; // 0x402115
    if (v1 < 6) {
        // 0x4020f6
        v2 = *(int32_t *)(4 * v1 + (int32_t)&g11);
    } else {
        v2 = (int32_t)"Unknown error";
    }
    float64_t v3 = *(float64_t *)(pexcept + 24); // 0x4020fd
    float64_t v4 = *(float64_t *)(pexcept + 16); // 0x402104
    float64_t v5 = *(float64_t *)(pexcept + 8); // 0x40210b
    int32_t v6 = *(int32_t *)(pexcept + 4); // 0x402112
    int32_t v7 = *(int32_t *)0x4061c8; // 0x402125
    fprintf((struct _IO_FILE *)(v7 + 64), "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", (char *)v2, (char *)v6, v5, v4, v3);
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pseudo-reloc.c
// Address range: 0x402140 - 0x402191
// Line range:    83 - 156
void __report_error(char * msg, ...) {
    int32_t v1 = *(int32_t *)0x4061c8; // 0x402144
    fwrite((int32_t *)"Mingw-w64 runtime failure:\n", 1, 27, (struct _IO_FILE *)(v1 + 64));
    int32_t v2;
    vfprintf((struct _IO_FILE *)(*(int32_t *)0x4061c8 + 64), msg, (int32_t)&v2);
    abort();
    // UNREACHABLE
}

// Address range: 0x402191 - 0x402193
int32_t function_402191(void) {
    // 0x402191
    mark_section_writable((char *)&g27);
    return &g27;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pseudo-reloc.c
// Address range: 0x4021a0 - 0x4022da
// Line range:    180 - 195
void mark_section_writable(char * addr) {
    // 0x4021a0
    g5 = maxSections;
    int32_t v1; // 0x4021de
    if (maxSections < 1) {
        // 0x40228d
        g5 = 0;
        v1 = g1;
    } else {
        uint32_t v2 = g1;
        int32_t v3 = 0; // 0x4021d4
        int32_t v4 = the_secs + 4; // 0x4021d7
        while (true) {
            uint32_t v5 = *(int32_t *)v4; // 0x4021c0
            if (v5 <= v2) {
                // 0x4021c6
                if (v2 < *(int32_t *)(*(int32_t *)(v4 + 4) + 8) + v5) {
                    // 0x402286
                    return;
                }
            }
            int32_t v6 = v3 + 1; // 0x4021d4
            if (v6 == maxSections) {
                v1 = v2;
                // break -> 0x4021de
                break;
            }
            v3 = v6;
            v4 += 12;
        }
    }
    // 0x4021de
    g3 = v1;
    int32_t v7 = __mingw_GetSectionForAddress((char *)v1); // 0x4021e3
    if (v7 == 0) {
        // 0x4022ca
        __report_error("Address %p has no image-section", (int32_t *)g3);
        // UNREACHABLE
    }
    int32_t v8 = 12 * g5; // 0x4021fb
    g3 = v8;
    int32_t v9 = the_secs + v8; // 0x4021fe
    *(int32_t *)(v9 + 8) = v7;
    *(int32_t *)v9 = 0;
    char * v10 = _GetPEImageBase(); // 0x402209
    int32_t v11 = *(int32_t *)(v7 + 12); // 0x40220e
    *(int32_t *)(v9 + 4) = v11 + (int32_t)v10;
    int32_t lpAddress = *(int32_t *)(the_secs + 4 + g3); // 0x402229
    int32_t lpBuffer; // bp-40
    if (VirtualQuery((int32_t *)lpAddress, (struct _MEMORY_BASIC_INFORMATION *)&lpBuffer, 28) == 0) {
        int32_t v12 = *(int32_t *)(the_secs + 4 + g3); // 0x4022af
        int32_t v13 = *(int32_t *)(v7 + 8); // 0x4022b7
        __report_error("  VirtualQuery failed for %d bytes at address %p", v13, (int32_t *)v12);
        // UNREACHABLE
    }
    int32_t v14;
    if ((v14 - 4 & -5) != 0) {
        if ((v14 - 64 & -65) != 0) {
            // 0x402251
            if (!VirtualProtect((int32_t *)28, lpBuffer, 64, (int32_t *)(the_secs + g3))) {
                // 0x402294
                __report_error("  VirtualProtect failed with code 0x%x", GetLastError());
                // UNREACHABLE
            }
        }
    }
    // 0x40227f
    maxSections++;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pseudo-reloc.c
// Address range: 0x4022e0 - 0x402597
// Line range:    464 - 378
void _pei386_runtime_relocator(void) {
    // 0x4022e0
    if (g12 != 0) {
        // 0x4022e9
        return;
    }
    // 0x4022f0
    g12 = 1;
    g1 = 12 * __mingw_GetSectionCount() + 30 & -16;
    maxSections = 0;
    the_secs = 31 - ___chkstk_ms() + g6 & -16;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/CRT_fp10.c
// Address range: 0x4025a0 - 0x4025a3
// Line range:    9 - 12
void _fpreset(void) {
    // 0x4025a0
    return;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/gccmain.c
// Address range: 0x4025b0 - 0x4025dc
// Line range:    20 - 29
void __do_global_dtors(void) {
    int32_t v1 = g8; // 0x4025b0
    if (*(int32_t *)v1 == 0) {
        // 0x4025da
        return;
    }
    int32_t v2 = v1 + 4; // 0x4025c7
    g8 = v2;
    while (*(int32_t *)v2 != 0) {
        // 0x4025c0
        v2 += 4;
        g8 = v2;
    }
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/gccmain.c
// Address range: 0x4025e0 - 0x402626
// Line range:    32 - 39
void __do_global_ctors(void) {
    int32_t v1 = g3; // 0x4025e0
    int32_t v2 = *(int32_t *)0x402e58; // 0x4025e4
    int32_t v3;
    if (v2 == -1) {
        // 0x402610
        if (*(int32_t *)0x402e5c == 0) {
            // 0x4025ff
            atexit((void (*)())0x4025b0);
            g3 = v1;
            return;
        }
        int32_t v4 = 1; // 0x402614
        v3 = v4;
        while (*(int32_t *)(4 * (v4 + 1) + 0x402e58) != 0) {
            // 0x402614
            v4++;
            v3 = v4;
        }
    } else {
        v3 = v2;
    }
    if (v3 == 0) {
        // 0x4025ff
        atexit((void (*)())0x4025b0);
        g3 = v1;
        return;
    }
    int32_t v5 = v3; // 0x4025fa6
    while (v5 != 1) {
        // 0x4025f3
        v5--;
    }
    // 0x4025ff
    atexit((void (*)())0x4025b0);
    g3 = v1;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/gccmain.c
// Address range: 0x402630 - 0x40264c
// Line range:    53 - 58
void __main(void) {
    // 0x402630
    if (initialized != 0) {
        // 0x402639
        return;
    }
    // 0x402640
    initialized = 1;
    __do_global_ctors();
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/gs_support.c
// Address range: 0x402650 - 0x4026fc
// Line range:    50 - 87
void __security_init_cookie(void) {
    int32_t lpSystemTimeAsFileTime = 0; // bp-44
    int32_t perfctr = 0; // bp-40
    if (__security_cookie != -0x44bf19b2) {
        // 0x402673
        __security_cookie_complement = -1 - __security_cookie;
        return;
    }
    // 0x402682
    GetSystemTimeAsFileTime((struct _FILETIME *)&lpSystemTimeAsFileTime);
    int32_t processId = GetCurrentProcessId(); // ebp
    int32_t threadId = GetCurrentThreadId(); // edi
    int32_t v1 = GetTickCount(); // esi
    QueryPerformanceCounter((struct _LARGE_INTEGER *)&perfctr);
    int32_t v2;
    int32_t v3 = lpSystemTimeAsFileTime ^ lpSystemTimeAsFileTime ^ v2 ^ perfctr ^ processId; // 0x4026ca
    int32_t v4 = v1 ^ threadId ^ v3; // 0x4026ce
    int32_t v5; // 0x4026dc
    int32_t v6; // 0x4026e2
    if (v4 == -0x44bf19b2) {
        // 0x4026f0
        v6 = 0x44bf19b0;
        v5 = -0x44bf19b1;
    } else {
        // 0x4026d8
        v6 = -1 - v4;
        v5 = v4;
    }
    // 0x4026dc
    __security_cookie = v5;
    __security_cookie_complement = v6;
    g4 = g3;
    g2 = g5;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/gs_support.c
// Address range: 0x402700 - 0x402787
// Line range:    103 - 145
void __report_gsfailure(int32_t StackCookie) {
    int32_t v1 = StackCookie;
    GS_ExceptionRecord = -0x3ffffbf7;
    g15 = 1;
    g14 = &v1;
    g13 = StackCookie;
    g16 = StackCookie;
    SetUnhandledExceptionFilter(NULL);
    UnhandledExceptionFilter((struct _EXCEPTION_POINTERS *)&GS_ExceptionPointers);
    TerminateProcess(GetCurrentProcess(), -0x3ffffbf7);
    abort();
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlsthrd.c
// Address range: 0x402790 - 0x4027fd
// Line range:    98 - 118
void __mingwthr_run_key_dtors(void) {
    // 0x402790
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
    int32_t v1 = key_dtor_list; // ebx
    int32_t v2; // bp-48
    int32_t v3 = &v2; // 0x4027aa
    int32_t v4; // 0x4027e5
    if (key_dtor_list != 0) {
        int32_t v5 = v3; // 0x4027c2
        int32_t v6 = key_dtor_list; // 0x4027c0
        while (true) {
            // 0x4027c0
            *(int32_t *)v5 = *(int32_t *)v6;
            int32_t * v7 = TlsGetValue((int32_t)&g27); // 0x4027c5
            if (!((v7 == NULL | GetLastError() != 0))) {
                // 0x4027d6
                *(int32_t *)g6 = (int32_t)v7;
            }
            int32_t v8 = *(int32_t *)(v1 + 8); // 0x4027de
            v1 = v8;
            if (v8 == 0) {
                v4 = g6;
                // break -> 0x4027e5
                break;
            }
            v5 = g6;
            v6 = v8;
        }
    } else {
        v4 = v3;
    }
    // 0x4027e5
    *(int32_t *)v4 = (int32_t)&__mingwthr_cs;
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&g27);
    g5 = *(int32_t *)(g6 + 28);
    g4 = *(int32_t *)(g6 + 32);
    g2 = *(int32_t *)(g6 + 36);
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlsthrd.c
// Address range: 0x402800 - 0x402877
// Line range:    41 - 49
int32_t ___w64_mingwthr_add_key_dtor(int32_t key, void (*dtor)(char *)) {
    // 0x402800
    if (__mingwthr_cs_init == 0) {
        // 0x402809
        return __mingwthr_cs_init;
    }
    int32_t * mem = calloc(1, 12); // 0x402823
    int32_t v1 = (int32_t)mem; // ebx
    int32_t result; // 0x40286f
    if (mem == NULL) {
        // 0x402870
        result = -1;
    } else {
        // 0x40282e
        *mem = key;
        *(int32_t *)(v1 + 4) = (int32_t)dtor;
        EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)(int32_t)&__mingwthr_cs);
        int32_t v2 = key_dtor_list; // 0x402848
        key_dtor_list = v1;
        *(int32_t *)(v1 + 8) = v2;
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)(int32_t)&__mingwthr_cs);
        result = 0;
    }
    // 0x40286b
    return result;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlsthrd.c
// Address range: 0x402880 - 0x40291d
// Line range:    64 - 82
int32_t ___w64_mingwthr_remove_key_dtor(int32_t key) {
    if (__mingwthr_cs_init == 0) {
        // 0x402891
        return 0;
    }
    // 0x4028a0
    EnterCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
    int32_t v1 = key_dtor_list; // 0x4028ad
    if (v1 == 0) {
        // 0x4028d1
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
        // 0x4028e1
        return 0;
    }
    // 0x4028ba
    if (*(int32_t *)v1 == key) {
        // 0x402910
        key_dtor_list = *(int32_t *)(v1 + 8);
        // 0x4028f6
        free((int32_t *)v1);
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
        // 0x4028e1
        return 0;
    }
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x4028ca9
    int32_t v3 = v2; // eax
    if (v2 == 0) {
        // 0x4028d1
        LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
        // 0x4028e1
        return 0;
    }
    int32_t v4; // 0x4028f0
    while (true) {
        // 0x4028c2
        v4 = *(int32_t *)(v2 + 8);
        if (*(int32_t *)v2 == key) {
            // break -> 0x4028f0
            break;
        }
        // 0x4028c8
        v3 = v4;
        if (v4 == 0) {
            // 0x4028d1
            LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
            // 0x4028e1
            return 0;
        }
        v1 = v2;
        v2 = v4;
    }
    // 0x4028f0
    *(int32_t *)(v1 + 8) = v4;
    // 0x4028f6
    free((int32_t *)v3);
    LeaveCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
    // 0x4028e1
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/tlsthrd.c
// Address range: 0x402920 - 0x4029b7
// Line range:    121 - 129
int32_t __mingw_TLScallback(char * hDllHandle, int32_t reason, char * reserved) {
    switch ((int32_t)hDllHandle) {
        case 1: {
            // 0x402974
            if (__mingwthr_cs_init == 0) {
                // 0x402990
                InitializeCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
            }
            // 0x40297d
            __mingwthr_cs_init = 1;
            return 1;
        }
        case 0: {
            int32_t v1 = __mingwthr_cs_init; // 0x402945
            int32_t v2; // 0x40294e
            if (v1 != 0) {
                // 0x4029b0
                __mingwthr_run_key_dtors();
                v2 = __mingwthr_cs_init;
            } else {
                v2 = v1;
            }
            if (v2 == 1) {
                // 0x402958
                __mingwthr_cs_init = 0;
                DeleteCriticalSection((struct _RTL_CRITICAL_SECTION *)&__mingwthr_cs);
            }
            // break -> 0x40293c
            break;
        }
        default: {
            if (hDllHandle != (char *)3) {
                // 0x40293c
                return 1;
            }
            // 0x402933
            if (__mingwthr_cs_init != 0) {
                // 0x4029a2
                __mingwthr_run_key_dtors();
            }
            // break -> 0x40293c
            break;
        }
    }
    // 0x40293c
    return 1;
}

// Address range: 0x4029c0 - 0x4029dd
int32_t __ValidateImageBase_part_0(void) {
    int32_t v1 = *(int32_t *)(g1 + 60) + g1; // 0x4029c0
    if (*(int32_t *)v1 == 0x4550) {
        // 0x4029d0
        return *(int16_t *)(v1 + 24) == 267;
    }
    // 0x4029cb
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x4029e0 - 0x4029f2
// Line range:    24 - 40
void _ValidateImageBase(char * pImageBase) {
    // 0x4029e0
    g1 = (int32_t)pImageBase;
    if (*(int16_t *)pImageBase != 0x5a4d) {
        // 0x4029eb
        return;
    }
    // 0x4029f0
    __ValidateImageBase_part_0();
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402a00 - 0x402a3d
// Line range:    45 - 62
int32_t _FindPESection(char * pImageBase, uint32_t rva) {
    int32_t v1 = (int32_t)pImageBase; // 0x402a02
    int32_t v2 = *(int32_t *)(v1 + 60) + v1; // 0x402a0a
    uint16_t v3 = *(int16_t *)(v2 + 6); // 0x402a0d
    if (v3 == 0) {
        // 0x402a3a
        return 0;
    }
    int32_t v4 = 0; // 0x402a2e
    int32_t result = v2 + 24 + (int32_t)*(int16_t *)(v2 + 20); // 0x402a31
    while (true) {
        uint32_t v5 = *(int32_t *)(result + 12); // 0x402a20
        if (v5 <= rva) {
            // 0x402a27
            if (*(int32_t *)(result + 8) + v5 > rva) {
                // 0x402a3a
                return result;
            }
        }
        int32_t v6 = v4 + 1; // 0x402a2e
        if (v6 == (int32_t)v3) {
            // break -> 0x402a38
            break;
        }
        v4 = v6;
        result += 40;
    }
    // 0x402a3a
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402a40 - 0x402adc
// Line range:    67 - 92
int32_t _FindPESectionByName(char * pName) {
    int32_t result = 0; // esi
    if (strlen(pName) < 9) {
        // 0x402a5a
        if (*(int16_t *)0x400000 == 0x5a4d) {
            // 0x402a70
            g1 = 0x400000;
            if (__ValidateImageBase_part_0() != 0) {
                int32_t v1 = *(int32_t *)0x40003c; // 0x402a7e
                uint16_t v2 = *(int16_t *)(v1 + 0x400006); // 0x402a90
                int32_t str = v1 + 0x400018 + (int32_t)*(int16_t *)(v1 + 0x400014); // 0x402a94
                if (v2 != 0) {
                    while (true) {
                        // 0x402aaa
                        if (strncmp((char *)str, (char *)(int32_t)pName, 8) == 0) {
                            // break -> 0x402ac2
                            break;
                        }
                        int32_t v3 = result + 1; // 0x402aa0
                        result = v3;
                        if (v3 == (int32_t)v2) {
                            // 0x402ad0
                            return 0;
                        }
                        str += 40;
                    }
                    // 0x402ac2
                    return str;
                }
            }
        }
    }
    // 0x402a65
    return result;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402ae0 - 0x402b30
// Line range:    98 - 109
int32_t __mingw_GetSectionForAddress(char * p) {
    int32_t v1 = g3; // 0x402ae0
    g3 = 0;
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x402af1
        g3 = v1;
        return 0;
    }
    // 0x402b00
    g1 = 0x400000;
    if (__ValidateImageBase_part_0() != 0) {
        // 0x402b0e
        g3 = v1;
        return _FindPESection((char *)0x400000, (int32_t)p - 0x400000);
    }
    int32_t result = g3; // 0x402af4
    // 0x402af1
    g3 = v1;
    return result;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402b30 - 0x402b5b
// Line range:    112 - 124
int32_t __mingw_GetSectionCount(void) {
    // 0x402b30
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x402b3d
        return 0;
    }
    // 0x402b40
    g1 = 0x400000;
    if (__ValidateImageBase_part_0() == 0) {
        // 0x402b3d
        return 0;
    }
    // 0x402b4e
    return (int32_t)*(int16_t *)(*(int32_t *)0x40003c + 0x400006);
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402b60 - 0x402bd7
// Line range:    130 - 155
int32_t _FindPESectionExec(int32_t eNo) {
    if (*(int16_t *)0x400000 == 0x5a4d) {
        // 0x402b80
        g1 = 0x400000;
        if (__ValidateImageBase_part_0() != 0) {
            int32_t v1 = *(int32_t *)0x40003c; // 0x402b8e
            uint16_t v2 = *(int16_t *)(v1 + 0x400006); // 0x402ba4
            if (v2 != 0) {
                int32_t v3 = 0; // 0x402bbd
                int32_t result = v1 + 0x400018 + (int32_t)*(int16_t *)(v1 + 0x400014); // 0x402bc0
                while (true) {
                    // 0x402bb0
                    if ((*(char *)(result + 39) & 32) != 0) {
                        int32_t v4 = eNo; // 0x402bb6
                        if (v4 == 0) {
                            // 0x402bd0
                            return result;
                        }
                        // 0x402bba
                        eNo = v4 - 1;
                    }
                    int32_t v5 = v3 + 1; // 0x402bbd
                    if (v5 == (int32_t)v2) {
                        // break -> 0x402bc7
                        break;
                    }
                    v3 = v5;
                    result += 40;
                }
                // 0x402bc7
                return 0;
            }
        }
    }
    // 0x402b73
    return 0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402be0 - 0x402c0a
// Line range:    160 - 167
char * _GetPEImageBase(void) {
    int32_t v1 = g3; // 0x402be0
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x402bee
        g3 = v1;
        return NULL;
    }
    // 0x402bf2
    g1 = 0x400000;
    g3 = v1;
    return __ValidateImageBase_part_0() != 0 ? (char *)0x400000 : (char *)0;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402c10 - 0x402c64
// Line range:    172 - 180
int32_t _IsNonwritableInCurrentImage(char * pTarget) {
    // 0x402c10
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x402c1d
        return 0;
    }
    // 0x402c20
    g1 = 0x400000;
    if (__ValidateImageBase_part_0() == 0) {
        // 0x402c56
        return 0;
    }
    int32_t v1 = _FindPESection((char *)0x400000, (int32_t)pTarget - 0x400000); // 0x402c45
    int32_t result; // 0x402c59
    if (v1 == 0) {
        result = 0;
    } else {
        // 0x402c4e
        result = *(int32_t *)(v1 + 36) > -1;
    }
    // 0x402c56
    return result;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/crt/pesect.c
// Address range: 0x402c70 - 0x402d0b
// Line range:    192 - 230
char * __mingw_enum_import_library_names(int32_t i) {
    int32_t v1 = 0; // edi
    g5 = i;
    if (*(int16_t *)0x400000 != 0x5a4d) {
        // 0x402c87
        return (char *)v1;
    }
    // 0x402c90
    g1 = 0x400000;
    if (__ValidateImageBase_part_0() == 0) {
        // 0x402c87
        return (char *)v1;
    }
    int32_t v2 = *(int32_t *)(*(int32_t *)0x40003c + 0x400080); // 0x402ca3
    g3 = v2;
    if (v2 == 0 || _FindPESection((char *)0x400000, v2) == 0) {
        // 0x402c87
        return (char *)v1;
    }
    // 0x402cc1
    if (v2 == -0x400000) {
        // 0x402c87
        return (char *)v1;
    }
    int32_t v3 = v2 + 0x400000; // 0x402cc1
    while (true) {
        // 0x402cd6
        if (*(int32_t *)(v3 + 4) == 0) {
            // 0x402cdd
            if (*(int32_t *)(v3 + 12) == 0) {
                // 0x402d00
                return NULL;
            }
        }
        int32_t v4 = g5; // 0x402ce4
        if (v4 >= 0 != v4 != 0) {
            // break -> 0x402ce8
            break;
        }
        // 0x402cd0
        g5 = v4 - 1;
        v3 += 20;
    }
    // 0x402ce8
    return (char *)(*(int32_t *)(v3 + 12) + 0x400000);
}

// Address range: 0x402d10 - 0x402d3a
int32_t ___chkstk_ms(void) {
    // 0x402d32
    return g1;
}

// From module:   C:/crossdev/gccmaster/host-toolchain-tdm64/x86_64-w64-mingw32/include/unistd.h
// Address range: 0x402d40 - 0x402d5d
// Line range:    34 - 16
int32_t sleep(int32_t seconds) {
    // 0x402d40
    Sleep(1000 * seconds);
    return 0;
}

// Address range: 0x402d60 - 0x402d66
void ___set_app_type(int32_t at) {
    // 0x402d60
    __set_app_type(at);
}

// Address range: 0x402d68 - 0x402d6e
int32_t ___getmainargs(int32_t * Argc, char *** Argv, char *** Env, int32_t DoWildCard, int32_t * StartInfo) {
    // 0x402d68
    return __getmainargs(Argc, Argv, Env, DoWildCard, StartInfo);
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/misc/invalid_parameter_handler.c
// Address range: 0x402d70 - 0x402d76
// Line range:    14 - 17
void (*mingw_get_invalid_parameter_handler(void))(int16_t *, int16_t *, int16_t *, int32_t, int32_t) {
    // 0x402d70
    return (void (*)(int16_t *, int16_t *, int16_t *, int32_t, int32_t))*(int32_t *)&handler;
}

// From module:   C:/crossdev/src/mingw-w64-v3-git/mingw-w64-crt/misc/invalid_parameter_handler.c
// Address range: 0x402d80 - 0x402d8b
// Line range:    6 - 9
void (*mingw_set_invalid_parameter_handler(void (*new_handler)(int16_t *, int16_t *, int16_t *, int32_t, int32_t)))(int16_t *, int16_t *, int16_t *, int32_t, int32_t) {
    // 0x402d80
    *(int32_t *)&handler = (int32_t)new_handler;
    return (void (*)(int16_t *, int16_t *, int16_t *, int32_t, int32_t))*(int32_t *)&handler;
}

// Address range: 0x402d90 - 0x402d96
int32_t * _malloc(int32_t size) {
    // 0x402d90
    return malloc(size);
}

// Address range: 0x402d98 - 0x402d9e
int32_t _strlen(char * s) {
    // 0x402d98
    return strlen(s);
}

// Address range: 0x402da0 - 0x402da6
int32_t * _memcpy(int32_t * dest, int32_t * src, int32_t n) {
    // 0x402da0
    return memcpy(dest, src, n);
}

// Address range: 0x402da8 - 0x402dae
void __cexit(void) {
    // 0x402da8
    _cexit();
}

// Address range: 0x402db0 - 0x402db6
void __amsg_exit(int32_t rterrnum) {
    // 0x402db0
    _amsg_exit(rterrnum);
}

// Address range: 0x402db8 - 0x402dbe
void __initterm(void (**First)(), void (**Last)()) {
    // 0x402db8
    _initterm(First, Last);
}

// Address range: 0x402dc0 - 0x402dc6
void _exit(int32_t status) {
    // 0x402dc0
    exit(status);
}

// Address range: 0x402dc8 - 0x402dce
int32_t _printf(char * format, ...) {
    // 0x402dc8
    return printf(format);
}

// Address range: 0x402dd0 - 0x402dd6
int32_t _sprintf(char * s, char * format, ...) {
    // 0x402dd0
    return sprintf(s, format);
}

// Address range: 0x402dd8 - 0x402dde
int32_t _strcmp(char * s1, char * s2) {
    // 0x402dd8
    return strcmp(s1, s2);
}

// Address range: 0x402de0 - 0x402de6
int32_t _puts(char * s) {
    // 0x402de0
    return puts(s);
}

// Address range: 0x402de8 - 0x402dee
struct _IO_FILE * _fopen(char * filename, char * modes) {
    // 0x402de8
    return fopen(filename, modes);
}

// Address range: 0x402df0 - 0x402df6
int32_t _fread(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * stream) {
    // 0x402df0
    return fread(ptr, size, n, stream);
}

// Address range: 0x402df8 - 0x402dfe
void __lock(int32_t locknum) {
    // 0x402df8
    _lock(locknum);
}

// Address range: 0x402e00 - 0x402e06
int32_t (*___dllonexit(int32_t (*func)(), void (***pbegin)(), void (***pend)()))() {
    // 0x402e00
    return __dllonexit(func, pbegin, pend);
}

// Address range: 0x402e08 - 0x402e0e
void __unlock(int32_t locknum) {
    // 0x402e08
    _unlock(locknum);
}

// Address range: 0x402e10 - 0x402e16
void (*_signal(int32_t sig, void (*handler2)(int32_t)))(int32_t) {
    // 0x402e10
    return signal(sig, handler2);
}

// Address range: 0x402e18 - 0x402e1e
void ___setusermatherr(int32_t pf) {
    // 0x402e18
    __setusermatherr(pf);
}

// Address range: 0x402e20 - 0x402e26
int32_t _fprintf(struct _IO_FILE * stream, char * format, ...) {
    // 0x402e20
    return fprintf(stream, format);
}

// Address range: 0x402e28 - 0x402e2e
int32_t _fwrite(int32_t * ptr, int32_t size, int32_t n, struct _IO_FILE * s) {
    // 0x402e28
    return fwrite(ptr, size, n, s);
}

// Address range: 0x402e30 - 0x402e36
int32_t _vfprintf(struct _IO_FILE * s, char * format, int32_t arg) {
    // 0x402e30
    return vfprintf(s, format, arg);
}

// Address range: 0x402e38 - 0x402e3e
void _abort(void) {
    // 0x402e38
    abort();
}

// Address range: 0x402e40 - 0x402e46
int32_t * _calloc(int32_t nmemb, int32_t size) {
    // 0x402e40
    return calloc(nmemb, size);
}

// Address range: 0x402e48 - 0x402e4e
void _free(int32_t * ptr) {
    // 0x402e48
    free(ptr);
}

// Address range: 0x402e50 - 0x402e56
int32_t _strncmp(char * s1, char * s2, int32_t n) {
    // 0x402e50
    return strncmp(s1, s2, n);
}

// --------------- Statically Linked Functions ----------------

// int32_t atexit(void (*a1)());

// --------------- Dynamically Linked Functions ---------------

// _onexit_t __dllonexit(_onexit_t func, _PVFV ** pbegin, _PVFV ** pend);
// int __getmainargs(int * Argc, char *** Argv, char *** Env, int DoWildCard, _startupinfo * StartInfo);
// int32_t __lconv_init(void);
// void __set_app_type(int at);
// void __setusermatherr(_HANDLE_MATH_ERROR pf);
// void _amsg_exit(int rterrnum);
// void __cdecl _cexit(void);
// void __cdecl _initterm(_In_ _PVFV * First, _In_ _PVFV * Last);
// void __cdecl _lock(int locknum);
// _onexit_t _onexit(_onexit_t Function);
// void __cdecl _unlock(int locknum);
// void abort(void);
// void * calloc(size_t nmemb, size_t size);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// VOID DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// VOID EnterCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// void exit(int status);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileA(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// BOOL FindNextFileA(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int fprintf(FILE * restrict stream, const char * restrict format, ...);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// HANDLE GetCurrentProcess(VOID);
// DWORD GetCurrentProcessId(VOID);
// DWORD GetCurrentThreadId(VOID);
// BOOL GetFileTime(_In_ HANDLE hFile, _Out_opt_ LPFILETIME lpCreationTime, _Out_opt_ LPFILETIME lpLastAccessTime, _Out_opt_ LPFILETIME lpLastWriteTime);
// DWORD GetLastError(VOID);
// VOID GetStartupInfoA(_Out_ LPSTARTUPINFOA lpStartupInfo);
// VOID GetSystemTimeAsFileTime(_Out_ LPFILETIME lpSystemTimeAsFileTime);
// DWORD GetTickCount(VOID);
// VOID InitializeCriticalSection(_Out_ LPCRITICAL_SECTION lpCriticalSection);
// VOID LeaveCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// BOOL QueryPerformanceCounter(_Out_ LARGE_INTEGER * lpPerformanceCount);
// BOOL SetFileTime(_In_ HANDLE hFile, _In_opt_ const FILETIME * lpCreationTime, _In_opt_ const FILETIME * lpLastAccessTime, _In_opt_ const FILETIME * lpLastWriteTime);
// LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// __sighandler_t signal(int sig, __sighandler_t handler);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// int sprintf(char * restrict s, const char * restrict format, ...);
// int strcmp(const char * s1, const char * s2);
// size_t strlen(const char * s);
// int strncmp(const char * s1, const char * s2, size_t n);
// BOOL TerminateProcess(_In_ HANDLE hProcess, _In_ UINT uExitCode);
// LPVOID TlsGetValue(_In_ DWORD dwTlsIndex);
// LONG UnhandledExceptionFilter(_In_ struct _EXCEPTION_POINTERS * ExceptionInfo);
// int vfprintf(FILE * restrict s, const char * restrict format, _G_va_list arg);
// BOOL VirtualProtect(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect);
// SIZE_T VirtualQuery(_In_opt_ LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, _In_ SIZE_T dwLength);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.9.2)
// Detected language: C
// Detected functions: 80
// Decompilation date: 2020-01-06 22:45:04
